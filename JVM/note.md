## JVM 运行时数据区域

![jdk 1.8](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

#### 线程私有的

* 虚拟机栈
* 程序计数器（是唯一不会出现OutOfMemory的区域，它的生命周期和线程相同）
* 本地方法栈
#### 线程共享的

* 堆
* 方法区（方法区是JVM规范中的定义，永久代是hotspot对方法区的一钟实现）
* 直接内存

#### 虚拟机栈

	虚拟机栈是线程私有的，由一个个栈帧组成，每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法返回值
	局部变量表主要存放基本数据类型和对象引用
	每一次函数调用都有一个栈帧被压入栈，方法调用完成对应一个栈帧弹出
	可能会发生StackOverFlowError和OutOfMemoryError。

#### 本地方法栈

	和虚拟机栈功能相似，虚拟机栈对应的是java方法，本地方法栈对应的是本地（Native）方法
	本地方法调用后同样有栈帧被压入本地方法栈
#### 堆

	对象的实例和数组在堆中分配，是垃圾收集的主要区域也成为GC堆
	可细分为新生代（eden,from survivor,to survivor）、老年代,划分的目的是为了更好地回收内存或者更快的分配内存
	eden、from survivor、to survivor   8:1:1

#### 运行时常量池

	运行时常量池是方法区中的一部分。
	class文件中除了有类的版本、字段、方法、接口等描述信息外还有常量池信息（存放编译器生成的字面量和符号引用）
	jdk1.7之后JVM已经将运行时常量池从方法区中移出，在堆中开辟区域存放运行时常量池（字符串常量池也是在堆中StringTable 为hash表结构）

class常量池：

	字面量：文本字符串、final修饰的常量、基本数据类型的值
	符号引用：类和接口的全限定名、字段的名称和修饰符、方法的名称和修饰符

jvm参数：

	-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 


GC Roots对象：

	虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性、常量引用的对象 ，本地方法栈中引用的对象

标记清除：	

	标记处所有需要回收的对象，标记完成后统一回收（会产生大量不连续的内存碎片，导致分配大对象时找不到连续的内存空间触发gc）
	复制算法：使用内存空间的一部分，当这一块内存使用完了就将存活的对象复制到另一块上面(只是用部分内存空间，还需要老年代对 to survivor进行担保)

标记整理：

	标记完所有需要回收的对象后，存活的对象向一端移动，移除边界外的对象

分代收集算法：

	新生代每次GC后只有少量对象存活，选用复制算法，只需要付出少量存活对象的复制成本

	老年代对象存活率高、没有额外的空间担保，使用标记整理算法

内存分配与回收策略：

	对象优先在eden去分配

	大对象可以直接进入老年代

	长期存活的对象进入老年代（对象在eden区出生，每经过一次MinorGC并存活下来年龄增加）

	相同年龄对象大小的总合占Survivor空间的一半是，年龄大于等于改年龄的对象直接进入老年代（Survivor空间指的是to survivor）

空间分配担保：

	MinorGC之前检查老年代最大连续可用空间是否大于新生代所有对象空间之和，条件成立则MinorGC确保是安全的，否则看是否允许担保失败，如果不允许则发生FullGC

	如果允许担保失败 检查老年代最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于则进行MinorGC，否则进行FullGC。

## 虚拟机对象

	为对象分配内存有两种方式：指针碰撞和空闲列表，选择哪种方式取决去堆中可用内存是否规整，堆是否规整取决于GC算法

指针碰撞：

	用过的内存和没用过的内存分别整合到一边，中间有个分界值指针，只需将指针向没用过的方向移动对象内存位置大小即可（适用内存规整的情况）
空闲列表：

	虚拟机维护一个列表，列表中记录那些内存块是可用的，找到足够大的内存分配给对象实例（适用于堆内存不规整的情况）

#### 内存分配并发问题

	TLAB（Thread Local Allocation Buffer）: 为每一个线程在eden区分配一块内存，jvm为线程内的对象分配空间时首先在这块内存分配，只有内存不足或用尽时，采用第二种CAS+失败重试方案
	
	CAS+失败重试：虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

#### 对象的内存布局

	对象在内存中可分为三个部分：对象头、实例数据、对齐填充

	对象头包括两部分一是哈希码、GC分代年龄、锁标志等信息，另一部分是类型指针，即指向类元数据的指针，通过这个指针确定对象是哪个类的实例

#### 对象的访问定位

	使用句柄：堆中会分配一块内存作为句柄池，reference中存储的就是句柄的地址，句柄中包含了对象的实例数据和元数据的地址信息
	直接指针： reference中存储的直接就是对象的地址
	使用句柄的好处是reference中固定存储句柄地址，对象移动后只需要改变句柄中的实例数据指针，reference本身不用改变
	使用直接指针好处是速度快，节省了一次指针定位的时间开销
	
使用new关键字实例化对象、读取或设置类的静态字段（被final修饰、已在编译期放入常量池的静态字段除外）、调用类的静态方法、初始化子类发现父类没有进行过初始化等情况会执行类的初始化


类加载机制：加载 验证 准备 解析 初始化 使用 卸载

加载阶段虚拟机完成3件事：

		1.通过类的全限定名获取定义此类的二进制字节流
		2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		3.在堆区内生成代表这个类的Class对象
				
准备阶段：为类变量（static修饰的，实例变量随对象一起分配在堆中）分配内存并设置初始值（在方法区分配）（数据类型的零值，final修饰的类变量会在准备阶段就初始实际值）	
	
解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程


类加载器：
启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）
双亲委派模型：一个类加载器收到了类加载的请求，首先将这个请求委派给父类加载器，当父类加载器搜索范围内没有找到所需的类时，子类加载器才会自己去加载


静态类型：指的是父类类型

依赖静态类型来定位方法执行版本的分派动作成为静态分派。在重载过程中使用的是静态分派。


垃圾收集器
	serial    	parNew   	parallel Scavenge
	serial old	cms		parallel old
	
	cms收集过程：初始标记  标记GC roots直接关联的对象 需要用户线程停顿
		   并发标记  用户线程和收集线程并发执行
		   重新标记   修正并发标记阶段用户线程 将已标记为死亡的对象重新建立引用的对象  需要用户线程停顿
		   并发清除  采取标记清除算法 不需要移动存活的对象所以可以和用户线程并发执行  
	cms采取标记清除算法，会产生大量不连续内存碎片，分配大内存对象时无法找到足够内存，触发full gc
	cms并发执行，虽然不会用户线程停顿，但是垃圾收集线程占用cpu资源，会使程序变慢
	cms并发清除，会产生浮动垃圾
	
	cms 如果对象上升到老年代很快，cms收集器不能保证足够的可用空间 或者 碎片化严重无法分配大内存对象时 并发失败 使用serial old进行gc 用户进程停顿	
		

	
