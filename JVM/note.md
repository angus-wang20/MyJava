-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
G Roots对象：虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性、常量引用的对象 ，本地方法栈中引用的对象
eden、from survivor、to survivor   8:1:1
标记清除：标记处所有需要回收的对象，标记完成后统一回收（会产生大量不连续的内存碎片，导致分配大对象时找不到连续的内存空间触发gc）
复制算法：使用内存空间的一部分，当这一块内存使用完了就将存活的对象复制到另一块上面(只是用部分内存空间，还需要老年代对 to survivor进行担保)
标记整理：标记完所有需要回收的对象后，存活的对象向一端移动，移除边界外的对象

分代收集算法：
新生代每次GC后只有少量对象存活，选用复制算法，只需要付出少量存活对象的复制成本
老年代对象存活率高、没有额外的空间担保，使用标记整理算法

对象在eden区出生，没经过一次MinorGC并存活下来年龄增加
内存分配与回收策略：
对象优先在eden去分配
大对象可以直接进入老年代
长期存活的对象进入老年代
相同年龄对象大小的总合占Survivor空间的一半是，年龄大于等于改年龄的对象直接进入老年代（Survivor空间指的是to survivor）

空间分配担保：
MinorGC之前检查老年代最大连续可用空间是否大于新生代所有对象空间之和，条件成立则MinorGC确保是安全的，否则看是否允许担保失败，如果不允许则发生FullGC
如果允许担保失败 检查老年代最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于则进行MinorGC，否则进行FullGC。

 
class常量池：
字面量：文本字符串、final修饰的常量
符号引用：类和接口的全限定名、字段的名称和修饰符、方法的名称和修饰符

使用new关键字实例化对象、读取或设置类的静态字段（被final修饰、已在编译期放入常量池的静态字段除外）、调用类的静态方法、初始化子类发现父类没有进行过初始化等情况会执行类的初始化

类加载机制：加载 验证 准备 解析 初始化 使用 卸载
加载阶段虚拟机完成3件事：1.通过类的全限定名获取定义此类的二进制字节流
				2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
				3.在方法区内生成代表这个类的Class对象
				
准备阶段：为类变量（static修饰的，实例变量随对象一起分配在堆中）分配内存并设置初始值（数据类型的零值，final修饰的类变量会在准备阶段就初始实际值）		
解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程


类加载器：
启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）
双亲委派模型：一个类加载器收到了类加载的请求，首先将这个请求委派给父类加载器，当父类加载器搜索范围内没有找到所需的类时，子类加载器才会自己去加载


静态类型：指的是父类类型
依赖静态类型来定位方法执行版本的分派动作成为静态分派。在重载过程中使用的是静态分派。	
