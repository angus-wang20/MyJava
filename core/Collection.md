## List

	LinkedList存储元素的结构是双向链表，由存储元素的节点连接而成，每一个节点都包含前一个几点、后一个节点的引用和节点存储的值
	ArrayList是数组实现，linkededlist是链表实现
	数组具有随机访问的特点 根据数组下标查询时间复杂度为O(1), 插入、删除操作可能会导致元素向后移位时间复杂度O(n), 数组要求连续的内存  ArrayList达到容量时触发扩容1.5倍
	s 链表查询元素需要遍历 时间复杂度O(n),插入、删除操作只影响前后两个节点 时间复杂度O(1)， 链表不要求连续的内存，天然支持动态扩容， 除数据额外存储后继节点的指针信息

## HashMap
	1.7中使用拉链法，1.8和hashmap相似为链表转为红黑树
	由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。
	hashmap 的容量达到阈值会触发扩容操作，扩容会涉及到rehash和数据的复制，因此尽量预估好hashmap的容量大小，减少性能损耗。
	使用拉链法处理hash冲突 当hash冲突严重时，链表会越来越长 查询效率会越来越低，时间复杂度为O(n) java8中当链表长度达到阈值（默认8）时链表转为红黑树 时间复杂度提升为O(logn)
	hashmap为线程不安全的 当扩容操作时并发情况下在一个桶上容易形成环形链表，出现死循环（1.7才会出现 原因是链表的插入采用的头插入法，并发下resize导致死循环）

#### Node
	key 写入的key
	value 写入的值
	hash 当前key的hash值
	next 指向链表结构的下一个节点

#### get操作
	key计算出hash值，然后定位到具体的数组下标
	判断该位置是否为链表 不是链表比较key和hash值是否相等
	是链表则遍历链表 找到hash值及key相等的节点
	找不到返回null
#### put操作
	根据计算出的 hashcode 定位出所在位置
	如果是一个链表则需要遍历判断里面的hashcode、key是否和传入的相等，如果相等则进行覆盖，并返回原来的值
	如果是空的则创建Node对象 加入当前位置


#### CurrentHashMap
	CurrentHashMap是线程安全的 jdk1.7中使用分段锁技术（每一段相当于一个map），可承受段数的线程并发, 其中segment继承自ReentrantLock
	jdk1.8中和hashmap结构相同，通过CAS+Synchronized实现同步，put操作桶位置为空时使用CAS写入，链表或是红黑树则使用Synchronized锁写入数据。
	1.8中的node对象 value和next都用volatile修饰，保证并发可见性
	1.7是对每个segement加锁，1.8是对数组中每个元素加锁


##### 
hashmap:数组 链表 红黑树的结构
get、put请求都是根据key的hash值去定位数组中的位置，数组中是node对象，node对象里面有key、hash、value、next指向下一个节点
put插入元素后会判断当前集合中的数量和扩容阈值进行比较，达到扩容标准会触发扩容 这个阈值时容量*负载因子得到的值
扩容时 容量扩充到原来的2倍
另外 链表的长度达到一定长度为变为红黑树，红黑树中的节点数量少于一定长度时退化为链表 还有就是hashmap线程不安全
